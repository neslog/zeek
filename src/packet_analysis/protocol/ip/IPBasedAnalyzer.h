// See the file "COPYING" in the main distribution directory for copyright.

#pragma once

#include "zeek/packet_analysis/Analyzer.h"
#include "zeek/packet_analysis/Component.h"
#include "zeek/analyzer/Analyzer.h"
#include "zeek/analyzer/Manager.h"

namespace zeek::analyzer::pia { class PIA; }

namespace zeek::packet_analysis::IP {

class IPBasedTransportAnalyzer;

/**
 * A base class for any packet analyzer based on IP. This is used by default by
 * the TCP, UDP, and ICMP analyzers to reduce a large amount of duplicated code
 * that those plugins have in common.
 */
class IPBasedAnalyzer : public Analyzer {
public:
	~IPBasedAnalyzer() override;

	/**
	 * Returns true if the analyzer determines that in fact a new
	 * connection has started without the connection statement having
	 * terminated the previous one, i.e., the new data is arriving at
	 * what's the analyzer for the previous instance. This is used only
	 * for TCP.
	 */
	virtual bool IsReuse(double t, const u_char* pkt) { return false; }

	/**
	 * TODO: comment
	 */
	virtual void CreateTransportAnalyzer(Connection* conn, IPBasedTransportAnalyzer*& root,
	                                     analyzer::pia::PIA*& pia, bool& check_port) = 0;

protected:

	IPBasedAnalyzer(const char* name);

	/**
	 * Creates a new Connection object based on the packet being analyzed. This also
	 * inserts the connection into the SessionManager.
	 *
	 * @param conn_id The connection ID generated by the child class.
	 * @param pkt The packet being processed.
	 * @param remaining The number of bytes remaining to be processed in the packet.
	 */
	void ProcessConnectionICMP(const ConnID& conn_id, const Packet* pkt, size_t remaining);

	/**
	 * Entry point for child classes to call to do the actual heavy lifting for
	 * processing a packet and extracting a connection out of it.
	 *
	 * @param conn_id The connection ID generated by the child class.
	 * @param pkt The packet being processed.
	 * @param remaining The number of bytes remaining to be processed in the packet.
	 */
	void ProcessConnection(const ConnID& conn_id, const Packet* pkt, size_t remaining);

	/**
	 * Verifies that there is enough data in the packet to process the header
	 * length requested.
	 *
	 * @param min_hdr_len The minimum data in bytes that needs to exist.
	 * @param remaining The remaining number of bytes in the packet reported by
	 * previous analyzer.
	 * @param packet The packet being processed. This will be used to pull out the
	 * number of bytes the IP header says we have remaining.
	 */
	bool CheckHeaderTrunc(size_t min_hdr_len, size_t remaining, Packet* packet);

	/**
	 * Upon seeing the first packet of a connection, checks whether we want
	 * to analyze it (e.g. we may not want to look at partial connections)
	 * and, if yes, whether we should flip the roles of originator and
	 * responder based on known ports and such.
	 *
	 * @param src_port The source port of the connection.
	 * @param dst_port The destination port of the connection.
	 * @param data The payload data for the packet being processed.
	 * @param flip_roles Return value if the roles should be flipped.
	 * @return True if the connection is wanted. False otherwise.
	 */
	virtual bool WantConnection(uint16_t src_port, uint16_t dst_port,
	                            const u_char* data, bool& flip_roles) const
		{
		flip_roles = false;
		return true;
		}

	/**
	 * Returns the port mask for an analyzer. Used by IsLikelyServerPort().
	 */
	virtual uint32_t GetServerPortMask() const = 0;

	/**
	 * Returns the transport protocol. Used by NewConn().
	 */
	virtual TransportProto GetTransportProto() const = 0;

	/**
	 * Returns true if the port corresponds to an application for which there
	 * is a Zeek analyzer (even if it might not be used by the present policy
	 * script) or if it's generally a likely server port.
	 *
	 * @param port The port number to check, in host order.
	 */
	bool IsLikelyServerPort(uint32_t port) const;

	virtual void ContinueProcessing(Connection* conn, double t, bool is_orig, int remaining,
	                                const Packet* pkt) {}

	/**
	 * The entry point to the session analysis framework. This should be reset between calls
	 * to ContinueProcessing(), as a packet analyzer should not maintain any state between
	 * packets.
	 */
	IPBasedTransportAnalyzer* session_analyzer;

	// TODO: temporary
	bool icmp = false;

private:

	/**
	 * Creates a new Connection object from data gleaned from the current packet.
	 *
	 * @param id A connection ID generated from the packet data. This should have been
	 * passed in from a child analyzer.
	 * @param key A connection ID key generated from the ID.
	 * @param pkt The packet associated with the new connection.
	 */
	zeek::Connection* NewConn(const ConnID* id, const detail::ConnIDKey& key,
	                          const Packet* pkt);

	/**
	 * Removes a connection from the session manager.
	 */
	void Remove(Connection* c);

	/**
	 * Sends a new connection to the session manager to be inserted and updates
	 * the statistics in the calling analyzer.
	 */
	void Insert(Connection* c);
};

/**
 * This class represents the interface between the packet analysis framework and
 * the session analysis framework. One of these should be implemented for each
 * packet analyzer that intends to forward into the session analysis.
 */
class IPBasedTransportAnalyzer : public zeek::analyzer::TransportLayerAnalyzer {

public:

	// TODO: comments
	IPBasedTransportAnalyzer(const char* name, Connection* conn)
		: TransportLayerAnalyzer(name, conn) { }

	void SetParent(IPBasedAnalyzer* p) { parent = p; }
	bool IsReuse(double t, const u_char* pkt) override { return parent->IsReuse(t, pkt); }
	virtual void AddExtraAnalyzers(Connection* conn) = 0;

protected:

	IPBasedAnalyzer* parent;
};

}
